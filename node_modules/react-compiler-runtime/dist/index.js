/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */

"use no memo";'use strict';

var React = require('react');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

var _a, _b;
const { useRef, useEffect, isValidElement } = React__namespace;
const ReactSecretInternals = (_a = React__namespace.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) !== null && _a !== void 0 ? _a : React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
const $empty = Symbol.for('react.memo_cache_sentinel');
const c = typeof ((_b = React__namespace.__COMPILER_RUNTIME) === null || _b === void 0 ? void 0 : _b.c) === 'function'
    ?
        React__namespace.__COMPILER_RUNTIME.c
    : function c(size) {
        return React__namespace.useMemo(() => {
            const $ = new Array(size);
            for (let ii = 0; ii < size; ii++) {
                $[ii] = $empty;
            }
            $[$empty] = true;
            return $;
        }, []);
    };
const LazyGuardDispatcher = {};
[
    'readContext',
    'useCallback',
    'useContext',
    'useEffect',
    'useImperativeHandle',
    'useInsertionEffect',
    'useLayoutEffect',
    'useMemo',
    'useReducer',
    'useRef',
    'useState',
    'useDebugValue',
    'useDeferredValue',
    'useTransition',
    'useMutableSource',
    'useSyncExternalStore',
    'useId',
    'unstable_isNewReconciler',
    'getCacheSignal',
    'getCacheForType',
    'useCacheRefresh',
].forEach(name => {
    LazyGuardDispatcher[name] = () => {
        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. ` +
            "Check that all hooks are called directly and named according to convention ('use[A-Z]') ");
    };
});
let originalDispatcher = null;
LazyGuardDispatcher['useMemoCache'] = (count) => {
    if (originalDispatcher == null) {
        throw new Error('React Compiler internal invariant violation: unexpected null dispatcher');
    }
    else {
        return originalDispatcher.useMemoCache(count);
    }
};
var GuardKind;
(function (GuardKind) {
    GuardKind[GuardKind["PushGuardContext"] = 0] = "PushGuardContext";
    GuardKind[GuardKind["PopGuardContext"] = 1] = "PopGuardContext";
    GuardKind[GuardKind["PushExpectHook"] = 2] = "PushExpectHook";
    GuardKind[GuardKind["PopExpectHook"] = 3] = "PopExpectHook";
})(GuardKind || (GuardKind = {}));
function setCurrent(newDispatcher) {
    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;
    return ReactSecretInternals.ReactCurrentDispatcher.current;
}
const guardFrames = [];
function $dispatcherGuard(kind) {
    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;
    if (kind === GuardKind.PushGuardContext) {
        guardFrames.push(curr);
        if (guardFrames.length === 1) {
            originalDispatcher = curr;
        }
        if (curr === LazyGuardDispatcher) {
            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. ` +
                "Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') " +
                'and (2) components are returned as JSX instead of being directly invoked.');
        }
        setCurrent(LazyGuardDispatcher);
    }
    else if (kind === GuardKind.PopGuardContext) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error('React Compiler internal error: unexpected null in guard stack');
        }
        if (guardFrames.length === 0) {
            originalDispatcher = null;
        }
        setCurrent(lastFrame);
    }
    else if (kind === GuardKind.PushExpectHook) {
        guardFrames.push(curr);
        setCurrent(originalDispatcher);
    }
    else if (kind === GuardKind.PopExpectHook) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error('React Compiler internal error: unexpected null in guard stack');
        }
        setCurrent(lastFrame);
    }
    else {
        throw new Error('React Compiler internal error: unreachable block' + kind);
    }
}
function $reset($) {
    for (let ii = 0; ii < $.length; ii++) {
        $[ii] = $empty;
    }
}
function $makeReadOnly() {
    throw new Error('TODO: implement $makeReadOnly in react-compiler-runtime');
}
const renderCounterRegistry = new Map();
function clearRenderCounterRegistry() {
    for (const counters of renderCounterRegistry.values()) {
        counters.forEach(counter => {
            counter.count = 0;
        });
    }
}
function registerRenderCounter(name, val) {
    let counters = renderCounterRegistry.get(name);
    if (counters == null) {
        counters = new Set();
        renderCounterRegistry.set(name, counters);
    }
    counters.add(val);
}
function removeRenderCounter(name, val) {
    const counters = renderCounterRegistry.get(name);
    if (counters == null) {
        return;
    }
    counters.delete(val);
}
function useRenderCounter(name) {
    const val = useRef(null);
    if (val.current != null) {
        val.current.count += 1;
    }
    useEffect(() => {
        if (val.current == null) {
            const counter = { count: 0 };
            registerRenderCounter(name, counter);
            val.current = counter;
        }
        return () => {
            if (val.current !== null) {
                removeRenderCounter(name, val.current);
            }
        };
    });
}
const seenErrors = new Set();
function $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {
    function error(l, r, path, depth) {
        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;
        if (seenErrors.has(str)) {
            return;
        }
        seenErrors.add(str);
        console.error(str);
    }
    const depthLimit = 2;
    function recur(oldValue, newValue, path, depth) {
        if (depth > depthLimit) {
            return;
        }
        else if (oldValue === newValue) {
            return;
        }
        else if (typeof oldValue !== typeof newValue) {
            error(`type ${typeof oldValue}`, `type ${typeof newValue}`, path, depth);
        }
        else if (typeof oldValue === 'object') {
            const oldArray = Array.isArray(oldValue);
            const newArray = Array.isArray(newValue);
            if (oldValue === null && newValue !== null) {
                error('null', `type ${typeof newValue}`, path, depth);
            }
            else if (newValue === null) {
                error(`type ${typeof oldValue}`, 'null', path, depth);
            }
            else if (oldValue instanceof Map) {
                if (!(newValue instanceof Map)) {
                    error(`Map instance`, `other value`, path, depth);
                }
                else if (oldValue.size !== newValue.size) {
                    error(`Map instance with size ${oldValue.size}`, `Map instance with size ${newValue.size}`, path, depth);
                }
                else {
                    for (const [k, v] of oldValue) {
                        if (!newValue.has(k)) {
                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);
                        }
                        else {
                            recur(v, newValue.get(k), `${path}.get(${k})`, depth + 1);
                        }
                    }
                }
            }
            else if (newValue instanceof Map) {
                error('other value', `Map instance`, path, depth);
            }
            else if (oldValue instanceof Set) {
                if (!(newValue instanceof Set)) {
                    error(`Set instance`, `other value`, path, depth);
                }
                else if (oldValue.size !== newValue.size) {
                    error(`Set instance with size ${oldValue.size}`, `Set instance with size ${newValue.size}`, path, depth);
                }
                else {
                    for (const v of newValue) {
                        if (!oldValue.has(v)) {
                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);
                        }
                    }
                }
            }
            else if (newValue instanceof Set) {
                error('other value', `Set instance`, path, depth);
            }
            else if (oldArray || newArray) {
                if (oldArray !== newArray) {
                    error(`type ${oldArray ? 'array' : 'object'}`, `type ${newArray ? 'array' : 'object'}`, path, depth);
                }
                else if (oldValue.length !== newValue.length) {
                    error(`array with length ${oldValue.length}`, `array with length ${newValue.length}`, path, depth);
                }
                else {
                    for (let ii = 0; ii < oldValue.length; ii++) {
                        recur(oldValue[ii], newValue[ii], `${path}[${ii}]`, depth + 1);
                    }
                }
            }
            else if (isValidElement(oldValue) || isValidElement(newValue)) {
                if (isValidElement(oldValue) !== isValidElement(newValue)) {
                    error(`type ${isValidElement(oldValue) ? 'React element' : 'object'}`, `type ${isValidElement(newValue) ? 'React element' : 'object'}`, path, depth);
                }
                else if (oldValue.type !== newValue.type) {
                    error(`React element of type ${oldValue.type}`, `React element of type ${newValue.type}`, path, depth);
                }
                else {
                    recur(oldValue.props, newValue.props, `[props of ${path}]`, depth + 1);
                }
            }
            else {
                for (const key in newValue) {
                    if (!(key in oldValue)) {
                        error(`object without key ${key}`, `object with key ${key}`, path, depth);
                    }
                }
                for (const key in oldValue) {
                    if (!(key in newValue)) {
                        error(`object with key ${key}`, `object without key ${key}`, path, depth);
                    }
                    else {
                        recur(oldValue[key], newValue[key], `${path}.${key}`, depth + 1);
                    }
                }
            }
        }
        else if (typeof oldValue === 'function') {
            return;
        }
        else if (isNaN(oldValue) || isNaN(newValue)) {
            if (isNaN(oldValue) !== isNaN(newValue)) {
                error(`${isNaN(oldValue) ? 'NaN' : 'non-NaN value'}`, `${isNaN(newValue) ? 'NaN' : 'non-NaN value'}`, path, depth);
            }
        }
        else if (oldValue !== newValue) {
            error(oldValue, newValue, path, depth);
        }
    }
    recur(oldValue, newValue, '', 0);
}

exports.$dispatcherGuard = $dispatcherGuard;
exports.$makeReadOnly = $makeReadOnly;
exports.$reset = $reset;
exports.$structuralCheck = $structuralCheck;
exports.c = c;
exports.clearRenderCounterRegistry = clearRenderCounterRegistry;
exports.renderCounterRegistry = renderCounterRegistry;
exports.useRenderCounter = useRenderCounter;
//# sourceMappingURL=index.js.map
